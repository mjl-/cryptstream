/*
Package cryptstream does streaming encryption & decryption with AES-CBC.
An io.Reader that reads plaintext can be wrapped into a reader that returns its ciphertext version, see Encrypter().
Decrypter() wraps a reader of ciphertext into a reader of a plaintext version.

An encrypted stream has the following format:

	- name of the encryption method (1 byte containing a length, following 30 bytes)
	- block size (1 byte)
	- iv (block size)
	- 1 or more encrypted chunks

Each chunk starts with a block, of which the last two bytes hold
the size of the actual data.  The data that follows is rounded up
to blocksize.  The end of the file is signaled with a chunk with
size 0.  The entire chunk is encrypted, including the size.

*/
package cryptstream

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "fmt"
        "io"
        "errors"
)

func encrypter(key []byte, rnd io.Reader, dst io.Writer, src io.Reader) error {
	if rnd == nil {
		rnd = rand.Reader
	}

	var mode string
	switch len(key) {
	case 16:
		mode = "aes-128-cbc"
	case 24:
		mode = "aes-192-cbc"
	case 32:
		mode = "aes-256-cbc"
	default:
		return fmt.Errorf("bad key size: %d", len(key))
	}
	blocksize := aes.BlockSize
	lead := make([]byte, 32+blocksize)
	lead[0] = uint8(len(mode))
	copy(lead[1:30], []byte(mode))
	lead[31] = uint8(blocksize)
	iv := lead[32:]
	_, err := io.ReadFull(rnd, iv)
	if err != nil {
		return err
	}

	b, err := aes.NewCipher(key)
	if err != nil {
		return err
	}

	_, err = dst.Write(lead)
	if err != nil {
		return err
	}

	bb := cipher.NewCBCEncrypter(b, iv)

	buf := make([]byte, blocksize+64*1024-blocksize)
	for {
		for i := 0; i < blocksize; i++ {
			buf[i] = byte(0)
		}

		n, err := io.ReadFull(src, buf[blocksize:])
		if err != nil && err != io.ErrUnexpectedEOF && err != io.EOF {
			return err
		}
		nn := ((n+blocksize-1)/blocksize)*blocksize
		for i := blocksize+n; i < blocksize+nn; i++ {
			buf[i] = byte(0)
		}
		if n > 0 {
			buf[blocksize-2] = uint8(n>>8)
			buf[blocksize-1] = uint8(n)
			bb.CryptBlocks(buf, buf[:blocksize+nn])
			_, err = dst.Write(buf[:blocksize+nn])
			if err != nil {
				return err
			}
		}
		if blocksize+n != len(buf) {
			buf = make([]byte, blocksize)
			bb.CryptBlocks(buf, buf)
			_, err = dst.Write(buf)
			if err != nil {
				return err
			}
			return nil
		}
	}
}

// Encrypter reads data from r and makes an encrypted version available on the returned reader.
// Encryption is done in a goroutine.
// The resulting stream is AES-CBC containing chunks of data, each chunk with a length block.
// A random IV is generated by reading a block of data from rnd.  If rnd is nil, crypto/rand's Reader is used.
func Encrypter(key []byte, rnd, r io.Reader) *io.PipeReader {
	pr, pw := io.Pipe()
	go func() {
		err := encrypter(key, rnd, pw, r)
		if err != nil {
			pw.CloseWithError(err)
			return
		}
		pw.Close()
	}()
	return pr
}

func decrypter(key []byte, dst io.Writer, src io.Reader) error {
	lead := make([]byte, 32)
	_, err := io.ReadFull(src, lead)
	if err != nil {
		return err
	}
	nsz := int(lead[0])
	if nsz > 30 {
		return errors.New("bad header")
	}
	name := string(lead[1:1+nsz])
	blocksize := int(lead[31])
	switch name {
	case "aes-128-cbc":
	case "aes-192-cbc":
	case "aes-256-cbc":
	default:
		return fmt.Errorf("unknown cipher/mode %q", name)
	}
	if blocksize != aes.BlockSize {
		return errors.New("bad blocksize in header")
	}

	iv := make([]byte, blocksize)
	_, err = io.ReadFull(src, iv)
	if err != nil {
		return fmt.Errorf("reading iv: %s", err)
	}

	b, err := aes.NewCipher(key)
	if err != nil {
		return err
	}
	bb := cipher.NewCBCDecrypter(b, iv)

	size := make([]byte, blocksize)
	buf := make([]byte, 64*1024-blocksize)
	for {
		_, err = io.ReadFull(src, size)
		if err != nil {
			return fmt.Errorf("reading size: %s", err)
		}
		bb.CryptBlocks(size, size)

		n := int(size[blocksize-2]) << 8 | int(size[blocksize-1])
		if n == 0 {
			return nil
		}

		nn := ((n+blocksize-1)/blocksize)*blocksize
		_, err = io.ReadFull(src, buf[:nn])
		if err != nil {
			return fmt.Errorf("reading chunk: %s", err)
		}
		bb.CryptBlocks(buf, buf[:nn])
		_, err = dst.Write(buf[:n])
		if err != nil {
			return err
		}
	}
}

// Decrypter reads an encrypted stream from r and makes a plain text version available on the returned reader.
// Decryption is done in a goroutine.
func Decrypter(key []byte, r io.Reader) *io.PipeReader {
	pr, pw := io.Pipe()
	go func() {
		err := decrypter(key, pw, r)
		if err != nil {
			pw.CloseWithError(err)
			return
		}
		pw.Close()
	}()
	return pr
}
